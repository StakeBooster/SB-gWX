{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# Стейкинг контракт
# Есть два варианта его работы:
# - Если задан родительский контракт, то будет при стейкинге, выводе и клейме вызывать его
# - Если родительский контракт не задан (у нас это будет использоваться для стейкинга SBT токенов)
# то при вызове claimPoolRewards будет распределять токены на контракте, полученные 
# через функцию receiveAdditionalReward
# - Также поддерживает лок застейканых пользователем токенов(нам тоже это нужно для SBT стейкинга)
# при каждом новом добавлении пользователем токенов через stake, текущие токены пользователя,
# которые он не вывел через withdraw, автоматически пролонгируются на лок период (если он есть)

# Константы
let MULT10 = 1_000_000_000_0
let SEP = "__"

# Данные пула
let isConstructedKey = "is_constructed"
let withdrawalLockPeriodKey = "withdrawal_lock_period"

let rewardAssetIdKey = "reward_asset_id"
let poolStakeAssetIdKey = "pool_stake_asset_id"
let rootContractAddressKey = "root_contract_address"
let adminAddressKey = "admin_address_key"

let totalPoolStakedKey = "total_pool__staked"
let totalPoolEarnedKey = "total_pool_earned"
let poolCurrentClaimIdKey = "pool_current_claim_id"
let poolCurrentUnclaimedAdditionalRewardsKey = "pool_current_unclaimed_additional_rewards"

func asPayment(v: Any) = match v {
    case p: AttachedPayment => p
    case _ => throw("fail to cast into AttachedPayment")
}

# Проверяет одно из основных ограничений для пользователя: если у него есть не склеймленные награды
# за предыдущие периоды, он не может делать stake или withdraw LP токенов, иначе математика работать не будет
func isUserHaveUnclaimedRewards(address: String) = {
  if !isDefined(getString(address)) then false
  else
    let currentPoolClaimId = getIntegerValue(poolCurrentClaimIdKey)
    let userData = split(getStringValue(address), SEP)
    let userLastClaimedRewardsAtPoolClaimId = parseIntValue(userData[2])
    userLastClaimedRewardsAtPoolClaimId < currentPoolClaimId
}

@Callable(i)
func constructor(rewardAssetId: String, poolStakeAssetId: String, withdrawalLockPeriod: Int, rootContract: String, adminContract: String) = {
  if isDefined(getBoolean(isConstructedKey)) then throw("Constructor can be called one time")
  else
    [
      BooleanEntry(isConstructedKey, true),
      IntegerEntry(poolCurrentUnclaimedAdditionalRewardsKey, 0),
      StringEntry(rewardAssetIdKey, rewardAssetId),
      StringEntry(poolStakeAssetIdKey, poolStakeAssetId),
      StringEntry(rootContractAddressKey, rootContract),
      StringEntry(adminAddressKey, adminContract),
      IntegerEntry(totalPoolEarnedKey, 0),
      IntegerEntry(poolCurrentClaimIdKey, 0),
      IntegerEntry(totalPoolStakedKey, 0),
      IntegerEntry(withdrawalLockPeriodKey, withdrawalLockPeriod)
    ]
}

# Ввод LP пользователя на контракт и завод их в стейкинг на WX через родительский контракт, вызывается пользователем
@Callable(i)
func stake() = {
  if size(i.payments) != 1 then throw("One Payment expected")
  else
    let callerAddress = toBase58String(i.caller.bytes)
    let payment = asPayment(getElement(i.payments, 0))
    let poolStakeAssetId = fromBase58String(getStringValue(poolStakeAssetIdKey))
    if payment.assetId != poolStakeAssetId || payment.amount <= 0 then throw("Wrong asset id or negative amount")
    else
    if isUserHaveUnclaimedRewards(callerAddress) then throw("You have unclaimed rewards on contract, claim them first")
    else
      # Текущие данные пула
      let currentPoolClaimId = getIntegerValue(poolCurrentClaimIdKey)
      let currentTotalPoolStaked = getIntegerValue(totalPoolStakedKey)
      let currentTotalPoolRewardsEarnedForOneStakeToken = getIntegerValue(totalPoolEarnedKey)
      let rootContractAddress = getStringValue(rootContractAddressKey)

      # Если задан родительский контракт, перебрасываем платеж туда
      strict result = if size(rootContractAddress) > 0 then
        invoke(Address(fromBase58String(rootContractAddress)), "stakePoolLps", [], [payment])
      else unit
      
      # Обновляем данные пользователя
      let userDataStr = valueOrElse(getString(callerAddress), "")

      let userData = if size(userDataStr) > 0 then
        let userData = split(userDataStr, SEP)
        let userTotalStakedAmount = parseIntValue(userData[0])
        makeString([
          (userTotalStakedAmount + payment.amount).toString(),
          userData[1],
          userData[2],
          userData[3],
          height.toString()
        ], SEP)
        else
        makeString([
          payment.amount.toString(), # Общее колл-во застейканых токенов пользователем
          "0", # Общее колл-во склеймленных пользователем токенов с пула
          currentPoolClaimId.toString(), # Текущий айди клейма пула
          currentTotalPoolRewardsEarnedForOneStakeToken.toString(), # Текущая пропорция заработка пула (колл-во склеймленных токенов/колл-во застейканых токенов)
          height.toString() # Текущий блок
        ], SEP)

      [
        StringEntry(callerAddress, userData),
        IntegerEntry(totalPoolStakedKey, currentTotalPoolStaked + payment.amount)
      ]
}

# Вывод LP с контратка, вызывается пользователем
@Callable(i)
func withdraw(amount: Int) = {
  if amount <= 0 then throw("Amount must be positive") else
  let callerAddress = toBase58String(i.caller.bytes)
  if isUserHaveUnclaimedRewards(callerAddress) then throw("You have unclaimed rewards on contract, claim them first")
  else
    let userData = split(valueOrErrorMessage(getString(callerAddress), "User not found"), SEP)
    let userTotalStakedAmount = parseIntValue(userData[0])
    if amount > userTotalStakedAmount then throw("Insufficient funds")
    else 
      # Если у пула есть лок период, проверяем возможность вывода
      let withdrawalLockPeriod = getIntegerValue(withdrawalLockPeriodKey)
      let userLastStakeBlock = parseIntValue(userData[4])
      if withdrawalLockPeriod > 0 && (height - userLastStakeBlock) < withdrawalLockPeriod then
        throw("This pool have lock period. You need to wait " + (withdrawalLockPeriod - (height - userLastStakeBlock)).toString() + " blocks") 
      else
        let rootContractAddress = getStringValue(rootContractAddressKey)
        let currentTotalPoolStaked = valueOrElse(getInteger(totalPoolStakedKey), 0)
        let poolStakeAssetId = getStringValue(poolStakeAssetIdKey)

        # Если задан родительский контракт, сначала выводим с него токены
        strict result = if size(rootContractAddress) > 0 then 
          invoke(Address(fromBase58String(rootContractAddress)), "withdrawPoolLps", [amount], [])
        else unit

        # Обновляем данные пользователя
        let newUserData = cons((userTotalStakedAmount - amount).toString(), removeByIndex(userData, 0))

        [
          IntegerEntry(totalPoolStakedKey, currentTotalPoolStaked - amount),
          ScriptTransfer(Address(i.caller.bytes), amount, fromBase58String(poolStakeAssetId))
        ] :+ if userTotalStakedAmount - amount == 0 then DeleteEntry(callerAddress)
        else StringEntry(callerAddress, makeString(newUserData, SEP))
}

# Клейм ревардов, вызывается пользователем
@Callable(i)
func claimRewards() = {
  let callerAddress = toBase58String(i.caller.bytes)
  if !isUserHaveUnclaimedRewards(callerAddress) then 
    throw("Nothing to claim, or user not found")
  else
    let poolCurrentClaimId = getIntegerValue(poolCurrentClaimIdKey)
    let totalPoolEarnedRewardsForOneStakeToken = getIntegerValue(totalPoolEarnedKey)

    let userData = split(getStringValue(callerAddress), SEP)
    let userTotalStaked = parseIntValue(userData[0])
    let userTotalRewardsClaimed = parseIntValue(userData[1])
    let userLastClaimPoolClaimId = parseIntValue(userData[2])
    let userAlreadyClaimedRewardsForOneStakeToken = parseIntValue(userData[3])

    # Вычисляем пропорцию ревардов, которую не склеймил пользователь
    let userUnclaimedPoolEarningsForOneStakeToken = 
      totalPoolEarnedRewardsForOneStakeToken - userAlreadyClaimedRewardsForOneStakeToken
    # Вычисляем колл-во полагающихся ему токенов исходя из этой пропорции
    let userClaim = fraction(userUnclaimedPoolEarningsForOneStakeToken, userTotalStaked, MULT10)
  
    let newUserData = makeString([
          userData[0], # Общее колл-во застейканых токенов пользователем
          (userTotalRewardsClaimed + userClaim).toString(), # Общее колл-во склеймленных пользователем токенов с пула
          poolCurrentClaimId.toString(), # Айди клейма пула, при котором пользователь сделал последний клейм
          (userAlreadyClaimedRewardsForOneStakeToken + userUnclaimedPoolEarningsForOneStakeToken).toString(), # Обновленная пропорция с учетом клейма
          userData[4]
        ], SEP)
    
    let rewardAssetId = fromBase58String(getStringValue(rewardAssetIdKey))

    [
      StringEntry(callerAddress, newUserData),
      ScriptTransfer(i.caller, userClaim, rewardAssetId)
    ]
}

# Клейм ревардов с WX контракта через родительский контракт на этот контракт, вызывается ТОЛЬКО раннером
@Callable(i)
func claimPoolRewards() = {
  if i.caller.bytes != fromBase58String(getStringValue(adminAddressKey)) then throw("Admin only") else
  let totalPoolStaked = getIntegerValue(totalPoolStakedKey)
  let totalPoolEarned = getIntegerValue(totalPoolEarnedKey)
  let poolCurrentClaimId = getIntegerValue(poolCurrentClaimIdKey)
  let rewardAssetId = fromBase58String(getStringValue(rewardAssetIdKey))
  let rootContractAddress = getStringValue(rootContractAddressKey)

  strict currentRewardOnContract = assetBalance(this, rewardAssetId)
  strict rootContractClaim = if size(rootContractAddress) > 0 then
    invoke(Address(fromBase58String(rootContractAddress)), "claimPoolRewards", [], [])
  else unit
  let newRewardOnContract = assetBalance(this, rewardAssetId)

  let currentAdditionalUnclaimedRewards = getIntegerValue(poolCurrentUnclaimedAdditionalRewardsKey)
  let claimedRewardAmount = (newRewardOnContract - currentRewardOnContract) + currentAdditionalUnclaimedRewards

  if claimedRewardAmount == 0 then []
  else
    # Вычисляем пропорцию(колл-во наградных токенов на один застейканый токен) за текущий клейм
    let currentClaimIdEarningsForOneStakeToken = fraction(claimedRewardAmount, MULT10, totalPoolStaked)

    [
      IntegerEntry(poolCurrentClaimIdKey, poolCurrentClaimId + 1),
      IntegerEntry(totalPoolEarnedKey, totalPoolEarned + currentClaimIdEarningsForOneStakeToken),
      IntegerEntry(poolCurrentUnclaimedAdditionalRewardsKey, 0)
    ]
}

# В нашей экосистеме будет вызываться родительским контрактом, если данный пул это STB стейкинг пул или
# пул, который на данный момент является получателем доп наград с других пулов
@Callable(i)
func receiveAdditionalReward() = {
  if size(i.payments) != 1 then throw("One Payment expected")
  else
    let payment = asPayment(getElement(i.payments, 0))
    let rewardAssetId = fromBase58String(getStringValue(rewardAssetIdKey))
    if payment.assetId != rewardAssetId || payment.amount <= 0 then throw("Wrong reward asset id or negative amount")
    else
      let currentUnclaimedAdditionalRewards = getIntegerValue(poolCurrentUnclaimedAdditionalRewardsKey)
      [
        IntegerEntry(poolCurrentUnclaimedAdditionalRewardsKey, currentUnclaimedAdditionalRewards + payment.amount)
      ]
}

@Verifier(tx)
func verify() = sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)
