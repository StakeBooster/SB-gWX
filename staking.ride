{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# Стейкинг контракт
# Есть два варианта его работы:
# - Если задан родительский контракт, то будет при стейкинге, выводе и клейме вызывать его
# - Если родительский контракт не задан (у нас это будет использоваться для стейкинга SBT токенов)
# то при вызове claimPoolRewards будет распределять токены на контракте, полученные 
# через функцию receiveAdditionalReward
# - Также поддерживает лок застейканых пользователем токенов(нам тоже это нужно для SBT стейкинга)
# при каждом новом добавлении пользователем токенов через stake, текущие токены пользователя,
# которые он не вывел через withdraw, автоматически пролонгируются на лок период (если он есть)

# Константы
let MULT10 = 1_000_000_000_0
let SEP = "__"
let rewardAssetsSEP = "///"
let nullKey = "NULL"

# Данные пула
let isConstructedKey = "is_constructed"
let withdrawalLockPeriodKey = "withdrawal_lock_period"

let rewardAssetIdsKey = "reward_asset_ids"
let poolStakeAssetIdKey = "pool_stake_asset_id"
let rootContractAddressKey = "root_contract_address"
let adminAddressKey = "admin_address_key"

let totalPoolStakedKey = "total_pool__staked"
let totalPoolEarnedKey = "total_pool_earned"
let poolCurrentClaimIdKey = "pool_current_claim_id"
let poolCurrentUnclaimedAdditionalRewardsKey = "pool_current_unclaimed_additional_rewards"

func asPayment(v: Any) = match v {
    case p: AttachedPayment => p
    case _ => throw("fail to cast into AttachedPayment")
}

# Проверяет одно из основных ограничений для пользователя: если у него есть не склеймленные награды
# за предыдущие периоды, он не может делать stake или withdraw LP токенов, иначе математика работать не будет
func isUserHaveUnclaimedRewards(address: String) = {
  if !isDefined(getString(address)) then false
  else
    let currentPoolClaimId = getIntegerValue(poolCurrentClaimIdKey)
    let userData = split(getStringValue(address), SEP)
    let userLastClaimedRewardsAtPoolClaimId = parseIntValue(userData[2])
    userLastClaimedRewardsAtPoolClaimId < currentPoolClaimId
}

# UPD: Пул теперь может принимать награды от 1 до трех наградных токенов.
@Callable(i)
func constructor(rewardAsset1Id: String, rewardAsset2Id: String, rewardAsset3Id: String, 
  poolStakeAssetId: String, withdrawalLockPeriod: Int, rootContract: String, adminContract: String) = {
  if isDefined(getBoolean(isConstructedKey)) then throw("Constructor can be called one time")
  else
    let rewardAsset1 = if size(rewardAsset1Id) == 0 then nullKey else rewardAsset1Id
    let rewardAsset2 = if size(rewardAsset2Id) == 0 then nullKey else rewardAsset2Id
    let rewardAsset3 = if size(rewardAsset3Id) == 0 then nullKey else rewardAsset3Id

    [
      BooleanEntry(isConstructedKey, true),
      StringEntry(poolCurrentUnclaimedAdditionalRewardsKey, makeString(["0","0","0"], rewardAssetsSEP)),
      StringEntry(rewardAssetIdsKey, makeString([rewardAsset1, rewardAsset2, rewardAsset3], rewardAssetsSEP)),
      StringEntry(poolStakeAssetIdKey, poolStakeAssetId),
      StringEntry(rootContractAddressKey, rootContract),
      StringEntry(adminAddressKey, adminContract),
      StringEntry(totalPoolEarnedKey, makeString(["0","0","0"], rewardAssetsSEP)),
      IntegerEntry(poolCurrentClaimIdKey, 0),
      IntegerEntry(totalPoolStakedKey, 0),
      IntegerEntry(withdrawalLockPeriodKey, withdrawalLockPeriod)
    ]
}

# Ввод LP пользователя на контракт и завод их в стейкинг на WX через родительский контракт, вызывается пользователем
@Callable(i)
func stake() = {
  if size(i.payments) != 1 then throw("One Payment expected")
  else
    let callerAddress = toBase58String(i.caller.bytes)
    let payment = asPayment(getElement(i.payments, 0))
    let poolStakeAssetId = fromBase58String(getStringValue(poolStakeAssetIdKey))
    if payment.assetId != poolStakeAssetId || payment.amount <= 0 then throw("Wrong asset id or negative amount")
    else
    if isUserHaveUnclaimedRewards(callerAddress) then throw("You have unclaimed rewards on contract, claim them first")
    else
      # Текущие данные пула
      let currentPoolClaimId = getIntegerValue(poolCurrentClaimIdKey)
      let currentTotalPoolStaked = getIntegerValue(totalPoolStakedKey)
      let currentTotalPoolRewardsEarnedForOneStakeToken = getStringValue(totalPoolEarnedKey)
      let rootContractAddress = getStringValue(rootContractAddressKey)

      # Если задан родительский контракт, перебрасываем платеж туда
      strict result = if size(rootContractAddress) > 0 then
        invoke(Address(fromBase58String(rootContractAddress)), "stakePoolLps", [], [payment])
      else unit
      
      # Обновляем данные пользователя
      let userDataStr = valueOrElse(getString(callerAddress), "")

      let userData = if size(userDataStr) > 0 then
        let userData = split(userDataStr, SEP)
        let userTotalStakedAmount = parseIntValue(userData[0])
        makeString([
          (userTotalStakedAmount + payment.amount).toString(),
          userData[1],
          userData[2],
          userData[3],
          height.toString()
        ], SEP)
        else
        makeString([
          payment.amount.toString(), # Общее колл-во застейканых токенов пользователем
          makeString(["0", "0", "0"], rewardAssetsSEP), # Общее колл-во склеймленных пользователем токенов с пула 
          currentPoolClaimId.toString(), # Текущий айди клейма пула
          currentTotalPoolRewardsEarnedForOneStakeToken, # Текущая пропорция заработка пула (колл-во склеймленных токенов/колл-во застейканых токенов)
          height.toString() # Текущий блок
        ], SEP)

      [
        StringEntry(callerAddress, userData),
        IntegerEntry(totalPoolStakedKey, currentTotalPoolStaked + payment.amount)
      ]
}

# Вывод LP с контратка, вызывается пользователем
# UPD: По новым данным от команды Waves Exchange, когда у них адрес делает вывод LP токенов, то они также 
# рассылают ему текущие награды за стейкинг. В нашем случае адрес - это пул, поэтому перед выводом нужно 
# обязательно собрать награды пула и вывести долю от них текущему пользователю
@Callable(i)
func withdraw(amount: Int) = {
  if amount <= 0 then throw("Amount must be positive") else
  let callerAddress = toBase58String(i.caller.bytes)
  let userData = split(valueOrErrorMessage(getString(callerAddress), "User not found"), SEP)
  let userTotalStakedAmount = parseIntValue(userData[0])
  if amount > userTotalStakedAmount then throw("Insufficient funds")
  else 
    # Если у пула есть лок период, проверяем возможность вывода
    let withdrawalLockPeriod = getIntegerValue(withdrawalLockPeriodKey)
    let userLastStakeBlock = parseIntValue(userData[4])
    if withdrawalLockPeriod > 0 && (height - userLastStakeBlock) < withdrawalLockPeriod then
      throw("This pool have lock period. You need to wait " + (withdrawalLockPeriod - (height - userLastStakeBlock)).toString() + " blocks") 
    else
      strict claimPoolRewardsResult = invoke(this, "claimPoolRewards", [], [])
      strict userClaimRewardsResult = if isUserHaveUnclaimedRewards(callerAddress) then 
        invoke(this, "claimRewards", [], []) else unit

      let rootContractAddress = getStringValue(rootContractAddressKey)
      let currentTotalPoolStaked = valueOrElse(getInteger(totalPoolStakedKey), 0)
      let poolStakeAssetId = getStringValue(poolStakeAssetIdKey)

      # Если задан родительский контракт, сначала выводим с него токены
      strict result = if size(rootContractAddress) > 0 then 
        invoke(Address(fromBase58String(rootContractAddress)), "withdrawPoolLps", [amount], [])
      else unit

      # Обновляем данные пользователя
      let newUserData = cons((userTotalStakedAmount - amount).toString(), removeByIndex(userData, 0))
      [
        IntegerEntry(totalPoolStakedKey, currentTotalPoolStaked - amount),
        ScriptTransfer(Address(i.caller.bytes), amount, fromBase58String(poolStakeAssetId))
      ] :+ if userTotalStakedAmount - amount == 0 then DeleteEntry(callerAddress)
      else StringEntry(callerAddress, makeString(newUserData, SEP))
}

# Клейм ревардов, вызывается пользователем
@Callable(i)
func claimRewards() = {
  let callerAddress = toBase58String(i.originCaller.bytes)
  if !isUserHaveUnclaimedRewards(callerAddress) then 
    throw("Nothing to claim, or user not found")
  else
    let poolCurrentClaimId = getIntegerValue(poolCurrentClaimIdKey)
    let totalPoolEarnedRewardsForOneStakeToken = split(getStringValue(totalPoolEarnedKey), rewardAssetsSEP)

    # Парсим данные по пользователю
    let userData = split(getStringValue(callerAddress), SEP)
    let userTotalStaked = parseIntValue(userData[0])
    let userTotalRewardsClaimed = split(userData[1], rewardAssetsSEP)
    let userLastClaimPoolClaimId = parseIntValue(userData[2])
  
    let userAlreadyClaimedRewardsForOneStakeToken = split(userData[3], rewardAssetsSEP)
    let userAlreadyClaimedRewardsAsset1ForOneStateToken = parseIntValue(userAlreadyClaimedRewardsForOneStakeToken[0])
    let userAlreadyClaimedRewardsAsset2ForOneStateToken = parseIntValue(userAlreadyClaimedRewardsForOneStakeToken[1])
    let userAlreadyClaimedRewardsAsset3ForOneStateToken = parseIntValue(userAlreadyClaimedRewardsForOneStakeToken[2])

    # Вычисляем пропорцию ревардов, которую не склеймил пользователь
    let userUnclaimedPoolEarningsAsset1ForOneStakeToken = 
      parseIntValue(totalPoolEarnedRewardsForOneStakeToken[0]) - userAlreadyClaimedRewardsAsset1ForOneStateToken
    let userUnclaimedPoolEarningsAsset2ForOneStakeToken = 
      parseIntValue(totalPoolEarnedRewardsForOneStakeToken[1]) - userAlreadyClaimedRewardsAsset2ForOneStateToken
    let userUnclaimedPoolEarningsAsset3ForOneStakeToken = 
      parseIntValue(totalPoolEarnedRewardsForOneStakeToken[2]) - userAlreadyClaimedRewardsAsset3ForOneStateToken
    
    # Вычисляем колл-во полагающихся ему токенов исходя из этой пропорции
    let userClaimAsset1 = if userUnclaimedPoolEarningsAsset1ForOneStakeToken == 0 then 0 
      else fraction(userUnclaimedPoolEarningsAsset1ForOneStakeToken, userTotalStaked, MULT10)
    let userClaimAsset2 = if userUnclaimedPoolEarningsAsset2ForOneStakeToken == 0 then 0
      else fraction(userUnclaimedPoolEarningsAsset2ForOneStakeToken, userTotalStaked, MULT10)
    let userClaimAsset3 = if userUnclaimedPoolEarningsAsset3ForOneStakeToken == 0 then 0 
      else fraction(userUnclaimedPoolEarningsAsset3ForOneStakeToken, userTotalStaked, MULT10)

    let newUserTotalRewardsClaimed = makeString([
      (parseIntValue(userTotalRewardsClaimed[0]) + userClaimAsset1).toString(),
      (parseIntValue(userTotalRewardsClaimed[1]) + userClaimAsset2).toString(),
      (parseIntValue(userTotalRewardsClaimed[2]) + userClaimAsset3).toString()
    ], rewardAssetsSEP)

    let newUserAlreadyClaimedRewardsForOneStakeToken = makeString([
      (userAlreadyClaimedRewardsAsset1ForOneStateToken + userUnclaimedPoolEarningsAsset1ForOneStakeToken).toString(),
      (userAlreadyClaimedRewardsAsset2ForOneStateToken + userUnclaimedPoolEarningsAsset2ForOneStakeToken).toString(),
      (userAlreadyClaimedRewardsAsset3ForOneStateToken + userUnclaimedPoolEarningsAsset3ForOneStakeToken).toString()
    ], rewardAssetsSEP)

    let newUserData = makeString([
          userData[0], # Общее колл-во застейканых токенов пользователем
          newUserTotalRewardsClaimed, # Общее колл-во склеймленных пользователем токенов с пула
          poolCurrentClaimId.toString(), # Айди клейма пула, при котором пользователь сделал последний клейм
          newUserAlreadyClaimedRewardsForOneStakeToken, # Обновленная пропорция с учетом клейма
          userData[4]
        ], SEP)
    
    let rewardAssetIds = split(getStringValue(rewardAssetIdsKey), rewardAssetsSEP)
    
    let initialResult = [StringEntry(callerAddress, newUserData)]
    let resultAfterAsset1Process = if rewardAssetIds[0] != nullKey && userClaimAsset1 > 0 
      then initialResult :+ ScriptTransfer(i.caller, userClaimAsset1, fromBase58String(rewardAssetIds[0]))
      else initialResult
    let resultAfterAsset2Process = if rewardAssetIds[1] != nullKey && userClaimAsset2 > 0
      then resultAfterAsset1Process :+ ScriptTransfer(i.caller, userClaimAsset2, fromBase58String(rewardAssetIds[1]))
      else resultAfterAsset1Process

    if rewardAssetIds[2] != nullKey && userClaimAsset3 > 0 
      then resultAfterAsset2Process :+ ScriptTransfer(i.caller, userClaimAsset3, fromBase58String(rewardAssetIds[2]))
      else resultAfterAsset2Process
}

# Клейм ревардов с WX контракта через родительский(main) контракт на этот контракт, вызывается ТОЛЬКО раннером
@Callable(i)
func claimPoolRewards() = {
  if i.caller.bytes != fromBase58String(getStringValue(adminAddressKey)) && i.caller != this 
  then throw("Admin or this contract only") else
  let totalPoolStaked = getIntegerValue(totalPoolStakedKey)
  let totalPoolEarned = split(getStringValue(totalPoolEarnedKey), rewardAssetsSEP)
  let poolCurrentClaimId = getIntegerValue(poolCurrentClaimIdKey)
  let rewardAssetIds = split(getStringValue(rewardAssetIdsKey), rewardAssetsSEP)
  let rootContractAddress = getStringValue(rootContractAddressKey)

  # Текущие балансы (по трем ревардным ассетам)
  strict currentRewardOnContractAsset1 = if rewardAssetIds[0] == nullKey then 0
    else  assetBalance(this, fromBase58String(rewardAssetIds[0]))
  strict currentRewardOnContractAsset2 = if rewardAssetIds[1] == nullKey then 0
    else  assetBalance(this, fromBase58String(rewardAssetIds[1]))
  strict currentRewardOnContractAsset3 = if rewardAssetIds[2] == nullKey then 0
    else  assetBalance(this, fromBase58String(rewardAssetIds[2]))

  strict rootContractClaim = if size(rootContractAddress) > 0 then
    invoke(Address(fromBase58String(rootContractAddress)), "claimPoolRewards", [], [])
  else unit

  # Обновленные балансы (по трем ревардным ассетам)
  let newRewardOnContractAsset1 = if rewardAssetIds[0] == nullKey then 0
    else  assetBalance(this, fromBase58String(rewardAssetIds[0]))
  let newRewardOnContractAsset2 = if rewardAssetIds[1] == nullKey then 0
    else  assetBalance(this, fromBase58String(rewardAssetIds[1]))
  let newRewardOnContractAsset3 = if rewardAssetIds[2] == nullKey then 0
    else  assetBalance(this, fromBase58String(rewardAssetIds[2]))

  # Дополнительные не склеймленные награды (по трем ревардным ассетам)
  let currentAdditionalUnclaimedRewards = split(getStringValue(poolCurrentUnclaimedAdditionalRewardsKey), rewardAssetsSEP)
  let claimedRewardAmountAsset1 = (newRewardOnContractAsset1 - currentRewardOnContractAsset1) + parseIntValue(currentAdditionalUnclaimedRewards[0])
  let claimedRewardAmountAsset2 = (newRewardOnContractAsset2 - currentRewardOnContractAsset2) + parseIntValue(currentAdditionalUnclaimedRewards[1])
  let claimedRewardAmountAsset3 = (newRewardOnContractAsset3 - currentRewardOnContractAsset3) + parseIntValue(currentAdditionalUnclaimedRewards[2])

  # Заработки за текущий период клейма (по трем ассетам)
  let currentClaimIdEarningsAsset1ForOneStakeToken = if claimedRewardAmountAsset1 > 0 then
    fraction(claimedRewardAmountAsset1, MULT10, totalPoolStaked) else 0
  let currentClaimIdEarningsAsset2ForOneStakeToken = if claimedRewardAmountAsset2 > 0 then
    fraction(claimedRewardAmountAsset2, MULT10, totalPoolStaked) else 0
  let currentClaimIdEarningsAsset3ForOneStakeToken = if claimedRewardAmountAsset3 > 0 then
    fraction(claimedRewardAmountAsset3, MULT10, totalPoolStaked) else 0
  
  # Обновленные общие заработки пула (по трем ассетам)
  let newTotalPoolEaned = makeString([
    (parseIntValue(totalPoolEarned[0]) + currentClaimIdEarningsAsset1ForOneStakeToken).toString(),
    (parseIntValue(totalPoolEarned[1]) + currentClaimIdEarningsAsset2ForOneStakeToken).toString(),
    (parseIntValue(totalPoolEarned[2]) + currentClaimIdEarningsAsset3ForOneStakeToken).toString()
  ], rewardAssetsSEP)

  [
    IntegerEntry(poolCurrentClaimIdKey, poolCurrentClaimId + 1),
    StringEntry(totalPoolEarnedKey, newTotalPoolEaned),
    StringEntry(poolCurrentUnclaimedAdditionalRewardsKey, makeString(["0","0","0"], rewardAssetsSEP))
  ]
}

# В нашей экосистеме будет вызываться родительским(main) контрактом, если данный пул это STB стейкинг пул или
# пул, который на данный момент является получателем доп наград с других пулов
@Callable(i)
func receiveAdditionalReward() = {
  if size(i.payments) != 3 then throw("Three Payments expected")
  else
    let currentUnclaimedAdditionalRewards = split(getStringValue(poolCurrentUnclaimedAdditionalRewardsKey), rewardAssetsSEP)
    let rewardAssetIds = split(getStringValue(rewardAssetIdsKey), rewardAssetsSEP)

    let newUnclaimedAdditinalRewardsAsset1 = if rewardAssetIds[0] == nullKey then currentUnclaimedAdditionalRewards[0]
      else
        let payment = asPayment(getElement(i.payments, 0))
        if payment.assetId != unit && payment.amount > 0 && payment.assetId == fromBase58String(rewardAssetIds[0])
        then (parseIntValue(currentUnclaimedAdditionalRewards[0]) + payment.amount).toString() else currentUnclaimedAdditionalRewards[0]

    let newUnclaimedAdditinalRewardsAsset2 = if rewardAssetIds[1] == nullKey then currentUnclaimedAdditionalRewards[1]
      else
        let payment = asPayment(getElement(i.payments, 1))
        if payment.assetId != unit && payment.amount > 0 && payment.assetId == fromBase58String(rewardAssetIds[1])
        then (parseIntValue(currentUnclaimedAdditionalRewards[1]) + payment.amount).toString() else currentUnclaimedAdditionalRewards[1]

    let newUnclaimedAdditinalRewardsAsset3 = if rewardAssetIds[2] == nullKey then currentUnclaimedAdditionalRewards[2]
      else
        let payment = asPayment(getElement(i.payments, 2))
        if payment.assetId != unit && payment.amount > 0 && payment.assetId == fromBase58String(rewardAssetIds[2])
        then (parseIntValue(currentUnclaimedAdditionalRewards[2]) + payment.amount).toString() else currentUnclaimedAdditionalRewards[2]
    [
      StringEntry(poolCurrentUnclaimedAdditionalRewardsKey, makeString([
        newUnclaimedAdditinalRewardsAsset1, newUnclaimedAdditinalRewardsAsset2, newUnclaimedAdditinalRewardsAsset3
      ], rewardAssetsSEP))
    ]
}

@Callable(i)
func setRewardAssets(rewardAsset1Id: String, rewardAsset2Id: String, rewardAsset3Id: String) = {
  if i.caller.bytes != fromBase58String(getStringValue(adminAddressKey)) 
  then throw("Admin only") 
  else
    let rewardAsset1 = if size(rewardAsset1Id) == 0 then nullKey else rewardAsset1Id
    let rewardAsset2 = if size(rewardAsset2Id) == 0 then nullKey else rewardAsset2Id
    let rewardAsset3 = if size(rewardAsset3Id) == 0 then nullKey else rewardAsset3Id
    [
      StringEntry(rewardAssetIdsKey, makeString([rewardAsset1, rewardAsset2, rewardAsset3], rewardAssetsSEP))
    ]
}

@Verifier(tx)
func verify() = sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)
